<resources>
    <string name="app_name">AiEdu</string>
    <string name="mail_subheader_title">Содержание</string>
    <string name="more">more</string>
    <string name="content_description_more">content_description_more</string>
    <string name="page_title">ML Guide Book</string>
    <string name="metrics_text">Метрики: Accuracy train: %.2f, Recall train: %.2f, F1 Score train: %.2f, Accuracy test: %.2f, Recall test: %.2f, F1 Score test: %.2f</string>
    <string name="lm_main_title">Линейные модели машинного обучения</string>
    <string name="lm_point1">Почему модели называют линейными?</string>
    <string name="lm_text1">Представьте, что у вас есть множество объектов, и вам нужно каждому объекту сопоставить определенное значение. Например, у вас есть список транзакций по банковской карте, и вы хотите определить, какие из этих транзакций являются мошенническими. Если вы разделите все операции на два класса, обозначив законные действия нулем, а мошеннические — единицей, то перед вами окажется простейшая задача классификации. Рассмотрим другой пример: у вас есть данные геологоразведки, и вы хотите оценить перспективы различных месторождений. В этом случае, используя набор геологических данных, ваша модель может прогнозировать, например, потенциальную годовую прибыль от эксплуатации шахты. Это пример задачи регрессии. Значения, которые мы хотим сопоставить объектам из нашего множества, иногда называют таргетами (от английского \"target\"). Таким образом, задачи классификации и регрессии можно свести к задаче поиска отображения от множества объектов к множеству возможных таргетов.</string>
    <string name="lm_point2">Что такое бинарная классификация?</string>
    <string name="lm_text2">Бинарная классификация — это задача машинного обучения, где нужно разделить данные на две категории (или классы). Например, определить, является ли сообщение спамом (1) или нет (0). Модель учится на примерах, чтобы предсказать вероятность принадлежности объекта к одному из двух классов.</string>
    <string name="lm_point3">Что такое логистическая регрессия?</string>
    <string name="lm_text3">Логистическая регрессия — это модель машинного обучения, которая используется для задач классификации. Несмотря на название, она связана с линейной регрессией, так как использует линейное уравнение для вычисления результата. Однако вместо точного значения модель выдает вероятность принадлежности объекта к определенному классу, преобразуя линейное уравнение с помощью логистической функции (сигмоиды), которая сжимает результат в диапазон от 0 до 1.</string>
    <string name="lm_point4">Как обучается модель?</string>
    <string name="lm_text4">Простой математический метод: Модель минимизирует ошибку (разницу между реальными и предсказанными значениями). Для этого используется функция потерь, например, логистическая функция ошибки. Процесс настройки параметров (весов) называется оптимизацией. Метод градиентного спуска (SGD): Модель начинает с произвольных значений параметров. Вычисляет, как изменить параметры, чтобы уменьшить ошибку (градиент функции потерь). Параметры обновляются в направлении, уменьшающем ошибку. В случае стохастического градиентного спуска (SGD) обновления происходят на основе каждого отдельного примера из данных, что делает обучение быстрым и адаптивным.</string>
    <!-- TODO: Remove or change this placeholder text -->
    <string name="hello_blank_fragment">▎Гайдбук по Моделям Машинного Обучения

▎Приветственное слово

Добро пожаловать в наш гайдбук по моделям машинного обучения (ML)! В этом руководстве мы познакомим вас с основными концепциями и методами, которые лежат в основе ML. Мы надеемся, что этот материал будет полезен как новичкам, так и тем, кто хочет освежить свои знания в этой динамично развивающейся области.

▎Что такое машинное обучение?

Машинное обучение — это подмножество искусственного интеллекта, которое позволяет компьютерам обучаться на данных и делать предсказания или принимать решения без явного программирования. С помощью алгоритмов и статистических моделей машины могут выявлять закономерности в данных, что делает ML мощным инструментом для решения различных задач.

▎Краткая историческая справка

История машинного обучения начинается в 1950-х годах с первых экспериментов в области искусственного интеллекта. С тех пор область значительно развилась, претерпев несколько этапов. В 1980-х годах появились нейронные сети, которые стали основой для современных подходов. В последние десятилетия с увеличением объема данных и вычислительных мощностей машинное обучение стало неотъемлемой частью многих технологий, от рекомендационных систем до автономных автомобилей.

▎Оглавление

1. Линейные модели

   • 1.1 Основы линейной регрессии

   • 1.2 Логистическая регрессия

   • 1.3 Применение линейных моделей

2. Деревья решений

   • 2.1 Принципы работы деревьев решений

   • 2.2 Алгоритмы построения деревьев (CART, ID3, C4.5)

   • 2.3 Преимущества и недостатки деревьев решений

3. Нейронные сети

   • 3.1 Введение в нейронные сети

   • 3.2 Архитектуры нейронных сетей (полносвязные, свёрточные, рекуррентные)

   • 3.3 Обучение и оптимизация нейронных сетей

Мы надеемся, что этот гайдбук поможет вам глубже понять модели машинного обучения и их применение в реальных задачах. Начнем наше путешествие в мир ML!</string>
    <string name="learn">Обучить!</string>
    <string name="metrics_void">Результаты:</string>
    <string name="lm_menu_name">Линейные модели</string>
    <string name="dt_menu_name">Деревья решений</string>
    <string name="ai_menu_name">Нейронные сети</string>
    <string name="value_hint">Оставьте пустым, если хотите MAX значение</string>
    <string name="value_eq">Значение=</string>
    <string name="dt_text1">1-ый параметр определяет стратегию разделения узлов в дереве. Он указывает, какое правило используется для выбора наилучшего критерия разбиения данных. Примеры правил: GINI: Критерий Джини. Используется для измерения степени \"чистоты\" узла. Наиболее часто применяется в задачах классификации. ENTROPY: Энтропия (информационный прирост). Основана на теории информации. Также применяется для классификации. Роль: Определяет, как дерево решает, на какой фиче и при каком пороге выполнить разделение данных.</string>
    <string name="dt_text2">Максимальная глубина дерева. Этот параметр задаёт, сколько уровней узлов может иметь дерево от корня до листа. Примеры: maxDepth = 3: Дерево будет состоять максимум из трёх уровней. maxDepth = Integer.MAX_VALUE: Ограничений на глубину нет. Роль: Контролирует сложность дерева: Маленькое значение уменьшает риск переобучения, но может привести к недообучению. Большое значение позволяет дереву обучаться более гибко, но может увеличивать вероятность переобучения.</string>
    <string name="dt_text3">Максимальное количество узлов (как внутренних, так и листьев) в дереве. Примеры: maxNodes = 10: В дереве может быть не больше 10 узлов. maxNodes = Integer.MAX_VALUE: Ограничений на количество узлов нет. Роль: Помогает ограничивать размер дерева, чтобы избежать переобучения. Может использоваться как альтернатива maxDepth.</string>
    <string name="dt_text4">Минимальный размер узла. Указывает минимальное количество наблюдений (примеров) в узле, при котором дерево может продолжать делить узел на подузлы. Примеры: nodeSize = 1: Узел будет разделён, если в нём есть хотя бы 1 пример. nodeSize = 10: Узел будет разделён, только если в нём есть минимум 10 примеров. Роль: Помогает избежать чрезмерного деления и создания слишком маленьких узлов. Увеличение этого параметра делает дерево более \"грубым\" и устойчивым к шуму, но может ухудшить качество модели.</string>
    <string name="gini">GINI</string>
    <string name="entropy">ENTROPY</string>
    <string name="dataset_chose_string">Выбираем DataSet</string>
    <string name="large_text">
        "Material is the metaphor.\n\n"

        "A material metaphor is the unifying theory of a rationalized space and a system of motion."
        "The material is grounded in tactile reality, inspired by the study of paper and ink, yet "
        "technologically advanced and open to imagination and magic.\n"
        "Surfaces and edges of the material provide visual cues that are grounded in reality. The "
        "use of familiar tactile attributes helps users quickly understand affordances. Yet the "
        "flexibility of the material creates new affordances that supercede those in the physical "
        "world, without breaking the rules of physics.\n"
        "The fundamentals of light, surface, and movement are key to conveying how objects move, "
        "interact, and exist in space and in relation to each other. Realistic lighting shows "
        "seams, divides space, and indicates moving parts.\n\n"

        "Bold, graphic, intentional.\n\n"

        "The foundational elements of print based design typography, grids, space, scale, color, "
        "and use of imagery guide visual treatments. These elements do far more than please the "
        "eye. They create hierarchy, meaning, and focus. Deliberate color choices, edge to edge "
        "imagery, large scale typography, and intentional white space create a bold and graphic "
        "interface that immerse the user in the experience.\n"
        "An emphasis on user actions makes core functionality immediately apparent and provides "
        "waypoints for the user.\n\n"

        "Motion provides meaning.\n\n"

        "Motion respects and reinforces the user as the prime mover. Primary user actions are "
        "inflection points that initiate motion, transforming the whole design.\n"
        "All action takes place in a single environment. Objects are presented to the user without "
        "breaking the continuity of experience even as they transform and reorganize.\n"
        "Motion is meaningful and appropriate, serving to focus attention and maintain continuity. "
        "Feedback is subtle yet clear. Transitions are efﬁcient yet coherent.\n\n"

        "3D world.\n\n"

        "The material environment is a 3D space, which means all objects have x, y, and z "
        "dimensions. The z-axis is perpendicularly aligned to the plane of the display, with the "
        "positive z-axis extending towards the viewer. Every sheet of material occupies a single "
        "position along the z-axis and has a standard 1dp thickness.\n"
        "On the web, the z-axis is used for layering and not for perspective. The 3D world is "
        "emulated by manipulating the y-axis.\n\n"

        "Light and shadow.\n\n"

        "Within the material environment, virtual lights illuminate the scene. Key lights create "
        "directional shadows, while ambient light creates soft shadows from all angles.\n"
        "Shadows in the material environment are cast by these two light sources. In Android "
        "development, shadows occur when light sources are blocked by sheets of material at "
        "various positions along the z-axis. On the web, shadows are depicted by manipulating the "
        "y-axis only. The following example shows the card with a height of 6dp.\n\n"

        "Resting elevation.\n\n"

        "All material objects, regardless of size, have a resting elevation, or default elevation "
        "that does not change. If an object changes elevation, it should return to its resting "
        "elevation as soon as possible.\n\n"

        "Component elevations.\n\n"

        "The resting elevation for a component type is consistent across apps (e.g., FAB elevation "
        "does not vary from 6dp in one app to 16dp in another app).\n"
        "Components may have different resting elevations across platforms, depending on the depth "
        "of the environment (e.g., TV has a greater depth than mobile or desktop).\n\n"

        "Responsive elevation and dynamic elevation offsets.\n\n"

        "Some component types have responsive elevation, meaning they change elevation in response "
        "to user input (e.g., normal, focused, and pressed) or system events. These elevation "
        "changes are consistently implemented using dynamic elevation offsets.\n"
        "Dynamic elevation offsets are the goal elevation that a component moves towards, relative "
        "to the component’s resting state. They ensure that elevation changes are consistent "
        "across actions and component types. For example, all components that lift on press have "
        "the same elevation change relative to their resting elevation.\n"
        "Once the input event is completed or cancelled, the component will return to its resting "
        "elevation.\n\n"

        "Avoiding elevation interference.\n\n"

        "Components with responsive elevations may encounter other components as they move between "
        "their resting elevations and dynamic elevation offsets. Because material cannot pass "
        "through other material, components avoid interfering with one another any number of ways, "
        "whether on a per component basis or using the entire app layout.\n"
        "On a component level, components can move or be removed before they cause interference. "
        "For example, a floating action button (FAB) can disappear or move off screen before a "
        "user picks up a card, or it can move if a snackbar appears.\n"
        "On the layout level, design your app layout to minimize opportunities for interference. "
        "For example, position the FAB to one side of stream of a cards so the FAB won’t interfere "
        "when a user tries to pick up one of cards.\n\n"
    </string>
    <string-array name="activations">
        <item>Linear</item>
        <item>Sigmoid</item>
        <item>Tanh</item>
        <item>RELU</item>
    </string-array>
</resources>